**Задачи взяты из [учебника](https://disk.yandex.ru/i/aAk3Bk2afa0Lqg) «‎Программирование на языке Python. Учебный курс (2017)». Авторы: Роберт Седжвик, Кевин Уэйн, Роберт Дондеро. В файле `codons.py` находится моё решение.**

# Проектирование, создание и использование высокоуровневых типов данных

Абстракция (abstraction) это упрощенное описание чего-то, включающее лишь основные элементы без всех остальных подробностей. Сложные системы в науке, технике и программировании всегда стараются понять через абстракцию. В программировани и на языке Python это осуществляется с использовани­ем объектно-ориентированного программирования (object-oriented programming), когда большая и потенциально сложная программа разделяется на набор взаимо­действующих элементов или объектов (object). Идея берет свое начало в компью­ терном моделировании реальных сущностей, таких как электроны, люди, стро­ения или солнечная система, и легко распространяется на моделирование такихабстрактных сущностей, как биты, числа, цвета, изображения или программы.

Сначала исследуем набор новых операций с объектами типа str как введение в объектно-ориентирован­ ное программирование, поскольку большинство этих операций реализуется как методы, манипулирующие объектами. Методы очень похожи на функции, за ис­ключением того, что каждый вызов метода явно ассоциируется с определенным объектом. Для иллюстрации обычного стиля программирования, подразумеваю­щего вызов методов, рассмотрим приложение обработки строк генома.

Обработка строк. В программировании на Python мы использовали тип данных str, чтобы создать удобочитаемый вывод наших программ. Наш опыт применения типа str показывает, что вы не обязаны знать, как реализован тип данных, чтобы использовать его. Вы уже знаете, что значения типа str - это последовательности символов, и вы можете выполнить операцию конкатенации двух значений типа str, чтобы получить результат типа str. Тип данных Python str подключает много и других операций. Это один из самых важных типов данных Python, поскольку обра­ботка строк критически важна для многих приложений. Строки лежат в основе нашей способности компилировать и выполнять программы Python, а также осу­ществлять множество других базовых вычислений; на них основано большин­ство систем обработки данных, критически важных для бизнес-систем. Люди используют их каждый день в электронных сообщениях, блогах, чатах или при подготовке документов к публикации; они критически важны в научном про­грессе, в частности в молекулярной биологии.

При ближайшем рассмотрении операции из API типа sr можно разделить на три категории:

* Встроенные операторы +, +=, [ ], [:], in, not in и операторы сравнения, характеризующиеся специальными символами и синтаксисом.
* Встроенная функция len() со стандартным синтаксисом вызова функции.
* Методы upper() , startswith(), find() и т.д.

Встроенные операторы. Оператор (или функция), применимый к нескольким типам данных, является полиморфным. Полиморфизм (polymorphism) это важ­нейшее достоинство языка программирования Pythoп и нескольких его встроенных операторов, позволяющее создавать компактный код, используя знакомые операторы при обработке любых типов данных. Для конкатенации строк вы уже использовали оператор +, знакомый по работе с числами. Для извлечения одного символа из строки, вы можете использовать оператор [], знакомый по работе с массивами, а для извлечения подстроки из строки - оператор [:].

Встроенные функции. Python обладает также множеством полиморфных функ­ций, таких как len() , которые, вероятно, будут иметь смысл для множества ти­пов данных. Когда тип данных реализует такую функцию, Pythoп автоматически вызывает эту реализацию на основании типа аргумента. Полиморфные функции похожи на полиморфные операторы, но без специального синтаксиса.

Методы. Мы включили сюда встроенные операторы и встроенные функции для полноты (и в соответствии с нормами Python), однако большая часть усилий при создании типов данных уходит на разработку методов, работающих с их объ­ектами, таких как upper(), startswith(), find(), и других методов.

# Обработка строк

Приложение обработки строк: геномика. Для приобретения большей практики в обработке строк исследуем очень короткий пример из области геномики (genomics) и создадим программу, которая могла бы пригодиться биоинформатикам для идентификации потенциальных генов. Для представления стандарт­ных блоков жизни биологи используют простую модель, где символы А, G, С и T представляют четыре основных азотистых основания в ДНК живых организмов.

Прогноз генов. Ген - это подстрока в геноме, представляющая функциональ­ный блок, критически важный для понимания жизненных процессов. Ген состо­ит из последовательности кодонов (codon), каждый из которых является последовательностью из трех оснований и представляет одну аминокислоту. Кодон начала (start codon), ATG, отмечает начало гена, а кодон конца (stop codon), TAG, ТАА или TGA, отмечает конец гена (внутри гена ни один из вариантов кодонов конца не используется). Один из первых этапов анализ генома подразумевает идентификацию потенциальных генов, что является задачей по обработке строк, для решения которой пригодится тип данных Python str.

Первым этапом будет программа PotentialGene Она получает как аргумент командной строки последовательность ДНК и определяет, соответству­ет ли она потенциальному гену на основании следующих критериев: длина кратна 3, начинается с кодона начала, завершается кодоном конца и не имеет никаких кодонов конца внутри. Для этого программа одновременно использует строко­вые методы, встроенные операторы и встроенные функции.

```python
# PotentialGene

def isPotentialGene(dna):
    # длина кратна 3
    if (len(dna) % 3) != 0: return False
    # начинается с кодона начала
    if not dna.startswith('ATG'): return False
    # не имеет кодонов конца внутри
    for i in range(len(dna) - 3):
        if i % 3 == 0:
            if dna[i:i+3] == 'TAA': return False
            if dna[i:i+3] == 'TAG': return False
            if dna[i:i+3] == 'TGA': return False
    # завершается кодоном конца
    if dna.endswith('TAA'): return True
    if dna.endswith('TAG'): return True
    if dna.endswith('TGA'): return True
    return False
```

В данном контексте наш интерес в том, чтобы проиллюстрировать, что тип данных str - это хорошо проработанная инкапсуляция важной абстракции, весьма полезная для клиентов. В решени и этой задачи нам помогут языковые механизмы Python, от полиморфных функций и операторов до методов, работа­ющих с объектами.

0. Составьте программу генерирущую строку, которая состоит из расположенных в случайном порядке букв A, T, C и G. Строка должна соответствовать условиям для потенциального гена. Она необходима для тестирования последующих заданий.
1. Составьте функцию isValidDNA(), получающую как аргумент строку и возвращающую значение Тrue, если и только если она состоит исключительно из символов А, С, Т и G.
2. Составьте функцию complementWC(), получающую как аргумент строку ДНК и возвращающую для нее дополнение Уотсона-Крика (Watson-Crick complement), заменив А на Т, С на G, и наоборот.
3. Составьте функцию palindromeWC() , получающую как аргумент строку ДНК и возвращающую значение True, если строка является комплемен­ тарным палиндромом Уотсона-Крика, и значение False в противном случае. Комплементарный палиндром Уотсона-Крика (Watson-Crick complemented palindrome) - это строка ДНК, обратная ее дополнению Уотсона-Крика.
4. Строка s является циклическим сдвигом строки t , если она получается в результате циклического сдвига символов на любое коли­чество позиций. Например, ACTGACG - это циклический сдвиг TGACGAC, и наоборот. Обнаружение этого условия важно в исследовании после­довательностей генов. Составьте функцию проверки, не являются ли две предоставленные строки s и t циклическим сдвигом друг друга. Подсказка: решение состоит из одной строки с оператором in и конкатенацией строк.
5. Составьте версию программы PotentialGene, находящую все потенциальные гены в длинной строке ДНК. Добавьте аргумент команд­ ной строки, позволяющий пользователю определять минимальную длину потенциального гена.
6. Составьте программу реализующую кодирование и декодирование шифром Цезаря
